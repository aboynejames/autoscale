/**
* Dsensor Ethereum API
*
*  using ethereum.org javascript API
* @class ethereurmjsAPI
*
* @package    dsensor.og  open source project
* @copyright  Copyright (c) 2015 James Littlejohn
* @license    http://ww
* @version    $Id$
*/
var util = require('util');
var events = require("events");
var Web3 = require('web3');
var fs = require('fs');


var ethereurmjsAPI = function() {

  //this.mappingprotocol = DsprotocolIN;
  //this.dmcomputeprotocol = DMcomputeIN;
  events.EventEmitter.call(this);
  this.web3 = new Web3();
//console.log(web3);
  this.web3.setProvider(new this.web3.providers.HttpProvider('http://localhost:8545'));
  //this.liveInflux = influxIN;
  this.publicaccount = '';
	this.livecontractslist = [];
  this.livestoragelist = [];
	this.livesensorlist = [];
  this.livedmaplist = [];
  this.livesamplinglist = [];
	this.abisensor = '';

	this.abi = '';

};

/**
* inherits core emitter class within this class
* @method
*/
util.inherits(ethereurmjsAPI, events.EventEmitter);

/**
*  check status of ethereum
* @method checkEthereum
*
*/
ethereurmjsAPI.prototype.checkEthereum = function() {

	var version = Web3.version.api;
	var versionc = Web3.version.client;

};

/**
*  MPPM list
* @method listMPPMContracts
* @return {array} list of smart contracts MPPM
*
*/
ethereurmjsAPI.prototype.listMPPMContracts = function() {

	var MPPMplist = [];
	MPPMplist = [112233];

	return MPPMplist;

};

/**
*  sensor list
* @method listSensorContracts
* @return {array} list of smart contracts sensors
*
*/
ethereurmjsAPI.prototype.listSensorContracts = function() {

	var sensorlist = [];
	sensorlist = [112233];

	return sensorlist;

};

/**
*  set ethereum public key
* @method checkAccounts
*
*
*/
ethereurmjsAPI.prototype.setPublickey = function(epubkey) {

  this.publicaccount = epubkey;
	this.web3.eth.defaultAccount = epubkey;
	this.checkAccounts();
};

/**
*  Check basic account details
* @method checkAccounts
*
*
*/
ethereurmjsAPI.prototype.checkAccounts = function() {
	// let's assume that coinbase is our account
//console.log(web3.eth.coinbase);
  var balether = this.web3.fromWei(this.web3.eth.getBalance(this.publicaccount), "ether")
console.log(balether + 'ether in account');
	var gasPrice = this.web3.eth.gasPrice;
console.log(gasPrice.toString(10));

};

/**
*  Send ether to another account
* @method etherSendtransaction
*
*
*/
ethereurmjsAPI.prototype.etherSendtransaction = function(receipient, value) {

	Web3.eth.sendTransaction({to: receipient, value: value}, function(err, address) {
	  if (!err)
	  {
console.log(address);

	  }
	  else
	  {
console.log(err);
	  }

	});

};

/**
*   read a file
* @method readSolidityfile
*
*
*/
ethereurmjsAPI.prototype.readSolidityfile = function(nameContract) {

  var filepath = 'smartcontracts/' + nameContract + '.sol';
  var contractdata = fs.readFileSync(filepath);
//console.log('data from solidity file');;
  return contractdata;
};

/**
*   create a permission  contract
* @method createPermissions
*
*
*/
ethereurmjsAPI.prototype.createPermissions = function() {
console.log('create permissoin for data access');
  var localthis = this;
  // solidity code code
  contractdata = this.readSolidityfile('permissions-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var code = compiled.sensorContract.code;
    // contract json abi, this is autogenerated using solc CLI
  var abi = compiled.sensorContract.info.abiDefinition;
  var myContract;
   var blockwatch = this.web3.eth.filter('latest');
  //console.log(blockwatch);

    this.web3.eth.contract(abi).new({data: code, gas: 900000}, function (err, contract) {

      if (err) {
console.error(err);
        return;
      }
      else if(contract.address) {
        myContract = contract;
console.log('address: ' + myContract.address);
        // call the contract
        localthis.livesensorlist.push(myContract.address);

      }
    });

};

/**
*   create a new Smart Contract
* @method createSensorcontract
*
*
*/
ethereurmjsAPI.prototype.createSensorcontract = function(formIN) {
console.log('create smart funcin class');
  var localthis = this;
  // solidity code code
  contractdata = this.readSolidityfile('sensor-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var code = compiled.sensorContract.code;
    // contract json abi, this is autogenerated using solc CLI
  var abi = compiled.sensorContract.info.abiDefinition;
  var myContract;
   var blockwatch = this.web3.eth.filter('latest');
  //console.log(blockwatch);

    this.web3.eth.contract(abi).new({data: code, gas: 900000}, function (err, contract) {

      if (err) {
console.error(err);
        return;
      }
      else if(contract.address) {
        myContract = contract;
console.log('address: ' + myContract.address);
        // call the contract
        myContract.setSensorBrand('Amiigo');
        myContract.setSensorMeasure('accelerometer');
        myContract.setSensorUnit('steps');
        myContract.setSensorOwner("0x52bddcd1897e2b7516b2218e69fda38c017c29b9");
        localthis.livesensorlist.push(myContract.address);

        //create linked storage API contract
        localthis.createStoragecontract(myContract.address);
        // update client UI with ID of dmap
        localthis.emit("newSensor-contract-id", myContract.address);
      }

    });

};

/**
*   create storage Access contract
* @method createStoragecontract
*
*
*/
ethereurmjsAPI.prototype.createStoragecontract = function(sensorContract) {
console.log('create storage api contract');
  var localthis = this;
  // solidity code code
  contractdata = this.readSolidityfile('storageapi-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var code = compiled.storageAccess.code;
    // contract json abi, this is autogenerated using solc CLI
  var abi = compiled.storageAccess.info.abiDefinition;
  var myContract;
   var blockwatch = this.web3.eth.filter('latest');
  //console.log(blockwatch);

    this.web3.eth.contract(abi).new({data: code, gas: 900000}, function (err, contract) {

      if (err) {
console.error(err);
        return;
      }
      else if(contract.address) {
        myContract = contract;
console.log('address: ' + myContract.address);
        // call the contract each storage contract is associated with a sensor smart contract
        myContract.setSensorAddress(sensorContract);

        // call the sensor contract and add storage contract ID (could call instance from sensor contract but keep simeple for now)
        var smartCdata = {};
        smartCdata.scid = sensorContract;
        smartCdata.storageCID = myContract.address;
        localthis.recallSensorContract("set-storage-contract", smartCdata);

        // update client UI with ID of storage contract
        var databack = {};
        databack.sensorscid = sensorContract;
        databack.storagescid = myContract.address;
        localthis.emit("newStorage-contract-id", databack);

      }
    });

};

/**
*   create a new Dmap contract
* @method createDmapcontract
*
*
*/
ethereurmjsAPI.prototype.createDmapcontract = function(formIN) {
console.log('create Dmap function class');
  var localthis = this;
  // solidity code code
  contractdata = this.readSolidityfile('dmap-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var code = compiled.DmapContract.code;
    // contract json abi, this is autogenerated using solc CLI
  var abi = compiled.DmapContract.info.abiDefinition;
  var myContract;
  var blockwatch = this.web3.eth.filter('latest');

    this.web3.eth.contract(abi).new({data: code, gas: 1500000}, function (err, contract) {

      if (err) {
console.error(err);
        return;
      }
      else if(contract.address) {
        myContract = contract;
console.log('address: ' + myContract.address);
        // call the contract
        myContract.setMappingDetail('science 21 centurary');
        // now with both dmap ID and Sampling ID(from within dmap contract)  make a hope  (that peer with then interact with ID of contracts)
        localthis.mappingprotocol.startSampling(myContract.address);
        // update client UI with ID of dmap
        localthis.emit("newDsample-contract-id", myContract.address);

      }
    });

};

/**
*   recall data from a smartcontract
* @method recallSensorContract
*
*
*/
ethereurmjsAPI.prototype.recallSensorContract = function(action, smcontractIN) {

  var contractdata = this.readSolidityfile('sensor-contract');

  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var code = compiled.sensorContract.code;
    // contract json abi, this is autogenerated using solc CLI
  var abi = compiled.sensorContract.info.abiDefinition;
  var myContract;
console.log('start recall process');
	var myContract = this.web3.eth.contract(abi);
	var mysamplingContract = myContract.at(this.livesensorlist[0]);
//console.log(mysamplingContract);


  // what action to perform on smart contract
  if(action == "set-storage-contract")
  {
    //
    mysamplingContract.setStorageContract(smcontractIN.storageCID);
    // tell UI smart contract was updated successfully

  }
  else if(action == "get-sensor-details")
  {
    // call the contract to return data
    var returnDmap = mysamplingContract.getBrand();
    // send back to UI

  }

};

/**
*   check permission and token
* @method recallStorageContract
*
*
*/
ethereurmjsAPI.prototype.recallStorageContract = function(action, smcontractIN) {

  var localthis = this;
  var contractdata = this.readSolidityfile('storageapi-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var code = compiled.storageAccess.code;
    // contract json abi, this is autogenerated using solc CLI
  var abi = compiled.storageAccess.info.abiDefinition;
  var myContract;
	var myContract = this.web3.eth.contract(abi);
	var mysamplingContract = myContract.at(smcontractIN.scid);
  //console.log(mysamplingContract);

  // what action to perform on smart contract
  if(action == "set-storage-ID")
  {
    //
    mysamplingContract.setSensorAddress(smcontractIN.scid);

  }
  else if(action == "set-permission")
  {
console.log('start of set permission action');
    // need to input list of permission askers
    var identityask = smcontractIN.pubethk;//'0xe4827d823aeea0017480b87df86aaa3e98d0937c';
    var permapi = smcontractIN.plevel;//2;
    mysamplingContract.setPermission(identityask, permapi);
    // send message to peer with contract ID
    var sendDHTmessage = {};
    sendDHTmessage.type = 'sendPermission';
    var buildtext = {};
    buildtext.pubethk = smcontractIN.pubethk;
    buildtext.scid = smcontractIN.scid;
    sendDHTmessage.text = buildtext;
    // need to serialse object
    var serialsendMessage = JSON.stringify(sendDHTmessage);
console.log(serialsendMessage);
    localthis.emit("permision-notify", serialsendMessage);

  }
  else if (action == "get-permission-status")
  {
    var returnpermission = mysamplingContract.getPermissionLevel();
console.log('Token permission =====');
console.log(returnpermission);
console.log(returnpermission.toString(10));

  }
  else if (action == "get-permission-history")
  {
      var pHistorydata = {};
      pHistorydata.scid = smcontractIN.scid;

      var phisoryList = mysamplingContract.getHistoryPermGranted();
      pHistorydata.list = phisoryList;
      localthis.emit("return-storperm-history", pHistorydata);

  }

};

/**
*   recall data from a Dmap contract
* @method recallDmapContract
*
*
*/
ethereurmjsAPI.prototype.recallDmapContract = function(action, contractID, nodeClass) {

  var localthis = this;
  var contractdata = this.readSolidityfile('dmap-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var code = compiled.DmapContract.code;
    // contract json abi, this is autogenerated using solc CLI
  var abi = compiled.DmapContract.info.abiDefinition;
  var myContract;
console.log('start DMAP recall process');
	var myContract = this.web3.eth.contract(abi);
	var mysamplingContract = myContract.at(contractID);

  // what action required on Dmap contract
  if(action == "sample-chosen")
  {
    //  set the various smart contract details
    //mysamplingContract.();

    // perform computation  extract github url from smart contract
//    var githuburl = mysamplingContract.getDMcode();
    // pass on to compute Protocol
  //  localthis.dmcomputeprotocol(githuburl);

    // select next node (emit message to get to DHT class) pass on the dmap contractID
    localthis.emit("sample-next", contractID, nodeClass);    //liveDHT.oneHop();

  }
  else if(action == "get-dmap-details")
  {
    // call the contract to return data
    var returnDmap = mysamplingContract.getMname();
console.log('Dmap ID =====');
console.log(returnDmap);
    // send back to UI

  }
  else if(action == "visualisation")
  {
    // get the storage and sensor details and proceed to visualisation
    // get the data and return to UI  HARDWIRES example wearable data for now
    localthis.dmcomputeprotocol.startCompute(contractID, this.liveInflux);

  }

};

/**
*  listening to the EVM blockchain for new smart contracts
* @method listenforMPPM
*
*
*/
ethereurmjsAPI.prototype.listenforMPPM = function() {


};


module.exports = ethereurmjsAPI;
