/**
* Dsensor Ethereum API
*
*  using ethereum.org javascript API
* @class ethereurmjsAPI
*
* @package    dsensor.og  open source project
* @copyright  Copyright (c) 2015 James Littlejohn
* @license    http://ww
* @version    $Id$
*/
var Web3 = require('web3');
var fs = require('fs');


var ethereurmjsAPI = function(protocolIN) {

  this.mappingprotocol = protocolIN;
console.log('access to network for smart contracts');
console.log(this.mappingprotocol);
  this.web3 = new Web3();
//console.log(web3);
  this.web3.setProvider(new this.web3.providers.HttpProvider('http://localhost:8545'));
  this.publicaccount = '';
	this.livecontractslist = [];
	this.livesensorlist = [];
  this.livedmaplist = [];
  this.livesamplinglist = [];
	this.abisensor = '';

	this.abi = '';
  this.setPublickey('52bddcd1897e2b7516b2218e69fda38c017c29b9');
};

/**
*  check status of ethereum
* @method checkEthereum
*
*/
ethereurmjsAPI.prototype.checkEthereum = function() {

	var version = Web3.version.api;
	var versionc = Web3.version.client;

};

/**
*  MPPM list
* @method listMPPMContracts
* @return {array} list of smart contracts MPPM
*
*/
ethereurmjsAPI.prototype.listMPPMContracts = function() {

	var MPPMplist = [];
	MPPMplist = [112233];

	return MPPMplist;

};

/**
*  sensor list
* @method listSensorContracts
* @return {array} list of smart contracts sensors
*
*/
ethereurmjsAPI.prototype.listSensorContracts = function() {

	var sensorlist = [];
	sensorlist = [112233];

	return sensorlist;

};

/**
*  set ethereum public key
* @method checkAccounts
*
*
*/
ethereurmjsAPI.prototype.setPublickey = function(epubkey) {

  this.publicaccount = epubkey;
	this.web3.eth.defaultAccount = epubkey;
	this.checkAccounts();
};

/**
*  Check basic account details
* @method checkAccounts
*
*
*/
ethereurmjsAPI.prototype.checkAccounts = function() {
	// let's assume that coinbase is our account
//console.log(web3.eth.coinbase);
  var balether = this.web3.fromWei(this.web3.eth.getBalance(this.publicaccount), "ether")
console.log(balether + 'ether in account');
	var gasPrice = this.web3.eth.gasPrice;
console.log(gasPrice.toString(10));

};

/**
*  Send ether to another account
* @method etherSendtransaction
*
*
*/
ethereurmjsAPI.prototype.etherSendtransaction = function(receipient, value) {

	Web3.eth.sendTransaction({to: receipient, value: value}, function(err, address) {
	  if (!err)
	  {
console.log(address);

	  }
	  else
	  {
console.log(err);
	  }

	});

};

/**
*   read a file
* @method readSolidityfile
*
*
*/
ethereurmjsAPI.prototype.readSolidityfile = function(nameContract) {

  var filepath = 'smartcontracts/' + nameContract + '.sol';
  var contractdata = fs.readFileSync(filepath);
//console.log('data from solidity file');;
  return contractdata;
};

/**
*   create a new Smart Contract
* @method createSensorcontract
*
*
*/
ethereurmjsAPI.prototype.createSensorcontract = function() {
console.log('create smart funcin class');
  var localthis = this;
  // solidity code code
  contractdata = this.readSolidityfile('sensor-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
console.log(compiled);
  var code = compiled.sensorContract.code;
console.log(code);
    // contract json abi, this is autogenerated using solc CLI
  var abi = compiled.sensorContract.info.abiDefinition;
console.log('that abi ===');
console.log(abi);
  var myContract;
   var blockwatch = this.web3.eth.filter('latest');
  //console.log(blockwatch);

    this.web3.eth.contract(abi).new({data: code, gas: 900000}, function (err, contract) {

      if (err) {
console.error(err);
        return;
      }
      else if(contract.address) {
        myContract = contract;
console.log('address: ' + myContract.address);
        // call the contract
        myContract.setSensorBrand('Amiigo');
        myContract.setSensorMeasure('accelerometer');
        myContract.setSensorUnit('steps');
        myContract.setSensorOwner("0x52bddcd1897e2b7516b2218e69fda38c017c29b9");
        localthis.livesensorlist.push(myContract.address);

      }
    });

};

/**
*   create a new Dmap contract
* @method createDmapcontract
*
*
*/
ethereurmjsAPI.prototype.createDmapcontract = function() {
console.log('create Dmap funcin class');
  var localthis = this;
  // solidity code code
  contractdata = this.readSolidityfile('dmap-contract');
  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
console.log(compiled);
  var code = compiled.DmapContract.code;
console.log(code);
    // contract json abi, this is autogenerated using solc CLI
  var abi = compiled.DmapContract.info.abiDefinition;
console.log('that abi ===');
console.log(abi);
  var myContract;
   var blockwatch = this.web3.eth.filter('latest');
  //console.log(blockwatch);

    this.web3.eth.contract(abi).new({data: code, gas: 1500000}, function (err, contract) {

      if (err) {
console.error(err);
        return;
      }
      else if(contract.address) {
        myContract = contract;
console.log('address: ' + myContract.address);
        // call the contract
        myContract.setMappingDetail('science 21 centurary');
        localthis.livedmaplist.push(myContract.address);

        // now with both dmap ID and Sampling ID  make a hope  (that peer with then interact with ID of contracts)
console.log(localthis.mappingprotocol);
        localthis.mappingprotocol.startSampling();

      }
    });

};

/**
*   recall data from a smartcontract
* @method recallSensorContract
*
*
*/
ethereurmjsAPI.prototype.recallSensorContract = function() {

  var contractdata = this.readSolidityfile('sensor-contract');

  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var code = compiled.sensorContract.code;
    // contract json abi, this is autogenerated using solc CLI
  var abi = compiled.sensorContract.info.abiDefinition;
  var myContract;
console.log('start recall process');
	var myContract = this.web3.eth.contract(abi);
	var mysamplingContract = myContract.at(this.livesensorlist[0]);
//console.log(mysamplingContract);
  // call the contract to return data
  var returnDmap = mysamplingContract.getBrand();
console.log('Dmap ID =====');
console.log(returnDmap);

};

/**
*   recall data from a Dmap contract
* @method recallDmapContract
*
*
*/
ethereurmjsAPI.prototype.recallDmapContract = function() {

  var contractdata = this.readSolidityfile('dmap-contract');

  var source = contractdata.toString();
  var compiled = this.web3.eth.compile.solidity(source);
  var code = compiled.DmapContract.code;
    // contract json abi, this is autogenerated using solc CLI
  var abi = compiled.DmapContract.info.abiDefinition;
  var myContract;
console.log('start recall process');
	var myContract = this.web3.eth.contract(abi);
	var mysamplingContract = myContract.at(this.livedmaplist[0]);
//console.log(mysamplingContract);
  // call the contract to return data
  var returnDmap = mysamplingContract.getMname();
console.log('Dmap ID =====');
console.log(returnDmap);

};

/**
*  listening to the EVM blockchain for new smart contracts
* @method listenforMPPM
*
*
*/
ethereurmjsAPI.prototype.listenforMPPM = function() {


};


module.exports = ethereurmjsAPI;
